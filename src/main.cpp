/*
******************************************************************************
File:     main.cpp
Info:     Generated by Atollic TrueSTUDIO(R) 6.0.0   2016-12-20

The MIT License (MIT)
Copyright (c) 2009-2016 Atollic AB

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
******************************************************************************
*/

/* Includes */
#include <stddef.h>
#include "stm32l1xx.h"
#include <stm32l1xx_gpio.h> // pre istotu sme pridali knižnicu GPIO

//#include <graphics.h>
//#include <dos.h>
#include <time.h>
#include <stdlib.h>
#include <stdio.h>
//#include <conio.h>

//#include <windows.h>

#include <unistd.h>

/*_________________________________________________________________________________________________________________________________________________________________*/
/*kod pre hru*/
struct bat
{
 int length;
 int width;
 int xcoordinate;
 int new_ycoordinate;
 int old_ycoordinate;
}batA, batB; // Create Two Bats For Each User.

struct ball
{
 int radius;
 int speedx;
 int speedy;
 int old_xcenter;
 int old_ycenter;
 int new_xcenter;
 int new_ycenter;
}ball1;

struct score
{
  int score_A;
  int score_B;
}score_game;


void initialize () // Initialize the game.
{
  int seconds = 15;

  int gdriver = DETECT, gmode;
  char tempstring [10]; //This String holds score in char format temporarily
  time_t t;// Used to generate random number from system time.
  closegraph ();
  initgraph(&gdriver, &gmode, "c:\\tc\\bgi"); // Intializes Graphics

  //Initialise Bat A
  batA.length = 40;
  batA.width = 2;
  batA.xcoordinate = 20;
  batA.new_ycoordinate = 237;
  batA.old_ycoordinate = 237;

  // Intialise Bat B
  batB.length = 40;
  batB.width = 2;
  batB.xcoordinate = 620;
  batB.new_ycoordinate = 237;
  batB.old_ycoordinate = 237;

   // Intialise Ball
   ball1.radius = 3;
   ball1.speedx = 2;
   srand((int) time(&t)); // Seed rand a random number
   ball1.speedy = rand ()%1;// Sets speed from 0 to 2 depending upon remainder.
   if (rand() % 2 == 0)
     {
       ball1.speedx = - ball1.speedx; // Generate Random X direction.
       ball1.speedy = - ball1.speedy; // Generate Random Y direction.
      }
    ball1.old_xcenter = 320;
    ball1.old_ycenter = 250;
    ball1.new_xcenter = 320;
    ball1.new_ycenter = 250;

   // Set Background to white
   setbkcolor (BLACK);

   // Draw Ball at Initial Position
   setfillstyle (1,15);
   fillellipse (ball1.new_xcenter,ball1.new_ycenter,ball1.radius,ball1.radius);

   // Draw Bats at Intial Position
   bar (batA.xcoordinate,batA.new_ycoordinate,batA.xcoordinate+batA.width,batA.new_ycoordinate+batA.length);
   bar (batB.xcoordinate,batB.new_ycoordinate,batB.xcoordinate+batB.width,batB.new_ycoordinate+batB.length);

   // Display Score
  // textcolor ();
   sprintf (tempstring,"A - %d",score_game.score_A);
   outtextxy (10,450,tempstring);
   sprintf (tempstring,"B - %d",score_game.score_B);
   outtextxy (590,450,tempstring);

   sprintf (tempstring,"Cas: %d sekund",seconds);
   outtextxy (290,5,tempstring);



}

void movebat (char input)

{
  switch (input)
     {
       case 'A' :
                  if (batA.new_ycoordinate > 0) // Move only when bat is not touching the top so it doesnt jump out of screen.
                    {
                      batA.old_ycoordinate = batA.new_ycoordinate;
                      batA.new_ycoordinate --;
                      setfillstyle (1,0); // Remove last postion.
                      bar (batA.xcoordinate,batA.old_ycoordinate,batA.xcoordinate+batA.width,batA.old_ycoordinate+batA.length);
                      setfillstyle (1,15); // Display New postion.
                      bar (batA.xcoordinate,batA.new_ycoordinate,batA.xcoordinate+batA.width,batA.new_ycoordinate+batA.length);
                     }
                   break;

       case 'Z' :
                  if (batA.new_ycoordinate+batA.length < 430) // Make sure bat doesnot go below the screen.
                    {
                      batA.old_ycoordinate = batA.new_ycoordinate;
                      batA.new_ycoordinate ++;
                      setfillstyle (1,0); // Remove last postion.
                      bar (batA.xcoordinate,batA.old_ycoordinate,batA.xcoordinate+batA.width,batA.old_ycoordinate+batA.length);
                      setfillstyle (1,15); // Display New postion.
                      bar (batA.xcoordinate,batA.new_ycoordinate,batA.xcoordinate+batA.width,batA.new_ycoordinate+batA.length);
                    }
                  break;
       case 'J' :
                  if (batB.new_ycoordinate > 0) // Move only when bat is not touching the top so it doesnt jump out of screen.
                     {
                      batB.old_ycoordinate = batB.new_ycoordinate;
                      batB.new_ycoordinate --;
                      setfillstyle (1,0); // Remove last postion.
                      bar (batB.xcoordinate,batB.old_ycoordinate,batB.xcoordinate+batB.width,batB.old_ycoordinate+batB.length);
                      setfillstyle (1,15); // Display New postion.
                      bar (batB.xcoordinate,batB.new_ycoordinate,batB.xcoordinate+batB.width,batB.new_ycoordinate+batB.length);
                     }
                  break;

        case 'M' :
                  if (batB.new_ycoordinate+batB.length < 430) // Make sure bat doesnot go below the screen.
                    {
                      batB.old_ycoordinate = batB.new_ycoordinate;
                      batB.new_ycoordinate ++;
                      setfillstyle (1,0); // Remove last postion.
                      bar (batB.xcoordinate,batB.old_ycoordinate,batB.xcoordinate+batB.width,batB.old_ycoordinate+batB.length);
                      setfillstyle (1,15); // Display New postion.
                      bar (batB.xcoordinate,batB.new_ycoordinate,batB.xcoordinate+batB.width,batB.new_ycoordinate+batB.length);
                    }
                   break;
         }

}

void moveball ()

{
   ball1.old_xcenter = ball1.new_xcenter;
   ball1.old_ycenter = ball1.new_ycenter;
   ball1.new_xcenter = ball1.new_xcenter + ball1.speedx;
   ball1.new_ycenter = ball1.new_ycenter + ball1.speedy;
   setcolor (0);
   setfillstyle (1,0); // Remove last postion.
   fillellipse (ball1.old_xcenter,ball1.old_ycenter,ball1.radius,ball1.radius);
   setfillstyle (1,15); // Display New postion.
   fillellipse (ball1.new_xcenter,ball1.new_ycenter,ball1.radius,ball1.radius);
   if ( ball1.new_ycenter - ball1.radius < 0 ) ball1.speedy = -ball1.speedy; // Reflect From Top
   if ( ball1.new_ycenter + ball1.radius > 430 ) ball1.speedy = -ball1.speedy; // Reflect From Bottom
}

void physics ()

{
  char tempstring [10];
  if ( ball1.new_xcenter - ball1.radius <= 20)
     {
         if (ball1.new_ycenter > batA.new_ycoordinate && ball1.new_ycenter < batA.new_ycoordinate+batA.length)
            {

               ball1.speedx = - ball1.speedx;
               ball1.speedy = rand () % 2;// Sets speed from 0 to 2 depending upon remainder.
               if (rand() % 2 == 0) ball1.speedy = - ball1.speedy; // Generate Random Y direction.
             }
          else // Reintialize entire game with new score
             {
               score_game.score_B ++;
               initialize ();
             }
          return;
      }

  if ( ball1.new_xcenter +  ball1.radius > 620)

      {
         if (ball1.new_ycenter > batB.new_ycoordinate && ball1.new_ycenter < batB.new_ycoordinate+batB.length)
          {

            ball1.speedx = - ball1.speedx;
            ball1.speedy = rand ()%2;// Sets speed from 0 to 2 depending upon remainder.
            if (rand() % 2 == 0) ball1.speedy = - ball1.speedy; // Generate Random Y direction.
           }
         else // Reintialize game with new score
          {
           score_game.score_A ++;
           initialize ();
          }
           return;
       }
}

void play ()
{


     time_t start = time(NULL);
     time_t endwait;
     int seconds = 15;

    endwait = start + seconds ;

  while (time (NULL) < endwait) // Check wether key press is Q if so exit loop
     {

       delay (10); // Reduce game speed to human playable level
      // if (inportb (0X60) == 30)  movebat ('A');
      // if (inportb (0X60) == 44)  movebat ('Z');
      // if (inportb (0X60) == 36)  movebat ('J');
      // if (1)  movebat ('M');
       moveball ();
       physics ();




      }


}
void vyhodnot()
{
  int gdriver = DETECT, gmode;
  char tempstring [10]; //This String holds score in char format temporarily
  time_t t;// Used to generate random number from system time.
  closegraph ();
  initgraph(&gdriver, &gmode, "c:\\tc\\bgi"); // Intializes Graphics

   // Set Background to white
   setbkcolor (BLACK);

   // Display Score
  // textcolor ();
   sprintf (tempstring,"A - %d",score_game.score_A);
   outtextxy (10,450,tempstring);
   sprintf (tempstring,"B - %d",score_game.score_B);
   outtextxy (590,450,tempstring);

  if (score_game.score_A > score_game.score_B){sprintf(tempstring,"Vytazom sa stal hrac A\n");}
  else if (score_game.score_A < score_game.score_B){sprintf(tempstring,"Vytazom sa stal hrac B\n");}
  else {sprintf(tempstring,"REMIZA\n");}

   outtextxy (290,300,tempstring);

  //time_t start = time(NULL);
   time_t endwait;
    int seconds = 5;

    endwait = time (NULL) + seconds ;

  while (time (NULL) < endwait) // Check wether key press is Q if so exit loop
     {

      }

    closegraph ();

}
/*_________________________________________________________________________________________________________________________________________________________________*/
/*kod pre ovladanie mikrokontrolera*/

void delay(unsigned int i) //nas casovac/spomalovac
{
	for (; i; i--)
		;
}

void adc_init(void) {
	GPIO_InitTypeDef GPIO_InitStructure;
	ADC_InitTypeDef ADC_InitStructure;
	/* Enable GPIO clock */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);

	/* Configure ADCx Channel 1 as analog input */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1; //zapojili sme tlacidlo na pin 1
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
	/* Enable the HSI oscillator */
	RCC_HSICmd(ENABLE);
	/* Check that HSI oscillator is ready */
	while (RCC_GetFlagStatus(RCC_FLAG_HSIRDY) == RESET);
	/* Enable ADC clock */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
	/* Initialize ADC structure */
	ADC_StructInit(&ADC_InitStructure);
	/* ADC1 configuration */
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
	ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_NbrOfConversion = 1;
	ADC_Init(ADC1, &ADC_InitStructure);
	/* ADCx regular channel8 configuration */
	ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 1, ADC_SampleTime_16Cycles); // pinu 1 zodpoveda kanal 1
			/* Enable the ADC */
	ADC_Cmd(ADC1, ENABLE);
	/* Wait until the ADC1 is ready */
	while (ADC_GetFlagStatus(ADC1, ADC_FLAG_ADONS) == RESET) {
	}
	/* Start ADC Software Conversion */
	ADC_SoftwareStartConv(ADC1);
}

int main(void) {

	  score_game.score_A = 0;// Intialise score in Main This Time
	  score_game.score_B = 0;// It improves Efficiency
	  char a='';
	  initialize ();
	  play (); // Game Engine

	  closegraph (); // Close Graphics

	  vyhodnot();

	  adc_init();
	  PA5_config();
	  while (1) {
		ADC_SoftwareStartConv(ADC1);
		while (!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC)) {
		}
		int AD_value = ADC_GetConversionValue(ADC1); // do AD_value  sa mi zapisuje hodnota vystupu z tlacidiel

		// èas kde pozorujem ktore tlacidlo je stlacene a podla toho nastavujem roznu rychlost blikania ledky
		//ak tlacidlo drzim stlacene tak ledka blika nizsie nastavenou rychlostou
		//pokial nedrzim tlacidlo tak sa ledka vypne
		//pre jednotlive tlacidla sme urcili rozmedzie pre AD_value +-cca 5.
		//pre tlacidlo 1 (najblizsie k dratom) to boli hodnoti cca v zormedzi 4046 až 4049
		if (AD_value > 3640 && AD_value < 3680) {
			a='A';
			movebat (a);
		}
		//tlacidlo 2
		else if (AD_value > 3445 && AD_value < 3490) {
			a='Z';
			movebat (a);
		}
		//tlacidlo 3
		else if (AD_value > 2900 && AD_value < 2950) {
			a='J';
			movebat (a);
		}
		//tlacidlo 4
		else if (AD_value > 2000 && AD_value < 2050) {
			a='M';
			movebat (a);
		}
		// nic nie je zatlacene
		else {

		}
	}

	return 0;
}

#ifdef  USE_FULL_ASSERT

/**
  * @brief  Reports the name of the source file and the source line number
  *   where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t* file, uint32_t line)
{
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */

  /* Infinite loop */
  while (1)
  {
  }
}
#endif

/*
 * Minimal __assert_func used by the assert() macro
 * */
extern "C" void __assert_func(const char *file, int line, const char *func, const char *failedexpr)
{
  while(1)
  {}
}

/*
 * Minimal __assert() uses __assert__func()
 * */
extern "C" void __assert(const char *file, int line, const char *failedexpr)
{
   __assert_func (file, line, NULL, failedexpr);
}
